


Given a gene annotation file in gtf of gff3 format, main_script.pl will store the annotation in a loutre database.


Dependencies:
- ensembl-otter (https://github.com/Annosoft/ensembl-otter)
- ensembl (https://github.com/Ensembl/ensembl)
- try-tiny (https://github.com/nothingmuch/try-tiny)


The user must provide:
- a gtf or gff3 annotation file;
- a valid dataset name, i.e. one that has already been added to the Otter server-config/ species.dat file in the ensembl-otter root branch (and commited and pushed to the live server);
- an author name - THERE IS NO DEFAULT NAME - FIX THIS;

Optionally:
- a transcript source info file, i.e. a file that includes the names of reads supporting each transcript model and/or the tissues where it was found;
- a remark that will be added as an attribute to each transcript (usually containing the ENA/GEO accession, as this can't be currently stored as an evidence)
- the "comp_pipe" flag must be set in order to enforce the use of the "comp_pipe" biotype, which will allow the models to be editable in Otter. Otherwise, the script will use the biotype provided in the annotation file. THERE IS NO DEFAULT BIOTYPE - FIX THIS

Usage:
perl main_script.pl -file ANNOTATION_FILE -source SOURCE_INFO_FILE -dataset DATASET_NAME -author AUTHOR_NAME -remark REMARK_STRING [-comp_pipe] [-write]

Example:
bsubmem2 -q yesterday -oo f.lw perl -I /software/ensembl/central/lib/site_perl/5.14.2/ -I /software/anacode/distro/precise/lib/site_perl/5.14.4/ ~/test_loutre_gene_insert/main_script.pl -file hsAll_Cap1_all_stranded.exons.all.gtag.HiSS.anchor.compmerge.cage+polyASupported.gtf.gz -source pooled_source_info.txt -dataset human_test_2 -author jmg -comp_pipe -remark "Assembled from PacBio CLS reads (GEO:GSE93848) using compmerge" -write


The script connects to the loutre database using the Otter logic. It creates a DataSet object that provides the DBAdaptor.
my $dataset = Bio::Otter::Server::Config->SpeciesDat->dataset($dataset_name);
my $otter_dba = $dataset->otter_dba or die "can't get db adaptor\n";

The script parses the annotation file into simple data structures [parse_gxf_file] and makes Bio::Vega gene objects [make_vega_objects]. A further step removes transcripts with long introns spanning multiple genes (likely produced by misalignments) [check_artifact_transcripts, recluster_transcripts]. THIS STEP HAS TO BE REFINED. If removing these transcripts leaves gaps in their genes, these loci are split accordingly.

The transcript sources are added now [add_sources]. WHY NOT AS THE VEGA OBJECTS ARE BEING CREATED? The transcript source file can be generated using the script extract_pasa_assembly_info.pl if the reads were assembled into transcript models using PASA. 


At this point, the script looks at storing the new gene objects in the database. First, it tries to find an existing host gene for each new transcript [assign_host_gene]. A host gene will always have exon overlap with the new transcript. If the transcript overlaps with several possible host genes, it will be assigned to the gene with the most matching introns, or else with the highest exon overlap. This implies that the transcripts originally in the same gene object can be distributed among several host genes. If there is no exon overlap between a new transcript and any existing gene, the transcript will be part of a new gene. 

This first step generates one or more gene objects containing only new transcripts and bearing the gene stable ids of the corresponding host genes, if any. Then, the second step will try to write the new gene objects in the database [process_gene]. For each gene, it fetches the corresponding Otter region, which must be large enough to include both the original gene and the host gene (otherwise, the script might fail to store some new transcripts). There are two possible write modes, determined by the script:
a)"update" mode: if the gene object to be stored has an existing stable id, ie. a host gene was found for one or more new transcripts. The script will add the new transcripts to the host gene and "write" the region, i.e store the changes. Note that a transcript will not be added if its intron chain is found in an existing transcript of the host gene. 
b)"add" mode: if there is no host gene, the script will add the new genes to the Otter region and store the changes.
In both modes, the script will also find new gene and transcript clone-based names (similarly to what Otter would do) before handing over to Otter [get_new_gene_names, get_new_transcript_names]. The Otter system will create new OTT gene and transcript stable ids, if necessary, when saving the changes to the region.









